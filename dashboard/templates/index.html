// Simplified chart rendering function for dashboard
function updateMainChart() {
    // Get current device
    const deviceId = document.getElementById('device-id')?.textContent || 'plt-404cca470da0';
    
    // Get selected metric and time range
    const selectedMetric = document.querySelector('.metric-btn.active')?.dataset.metric || 'combined';
    const timeMinutes = parseInt(document.querySelector('.time-btn.active')?.dataset.minutes || 1440);
    
    console.log(`Loading chart: ${selectedMetric}, device: ${deviceId}, minutes: ${timeMinutes}`);
    
    // Get chart container
    const chartContainer = document.querySelector('.trends-container');
    if (!chartContainer) {
        console.error('Chart container not found');
        return;
    }
    
    // Show loading state
    chartContainer.innerHTML = '<div class="loading-message">Loading chart data...</div>';
    
    // Handle combined chart separately
    if (selectedMetric === 'combined') {
        loadCombinedChart(deviceId, timeMinutes, chartContainer);
        return;
    }
    
    // For single metric charts, use direct API
    fetch(`/api/query?metric=${selectedMetric}&device=${deviceId}&minutes=${timeMinutes}`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            // Prepare chart data
            const chartData = processChartData(data, selectedMetric);
            
            // Render chart
            renderChart(chartContainer, selectedMetric, chartData);
        })
        .catch(error => {
            console.error('Error loading chart:', error);
            chartContainer.innerHTML = `<div class="error-message">Error loading chart: ${error.message}</div>`;
        });
}

// Process data from API response
function processChartData(response, metric) {
    const labels = [];
    const values = [];
    
    // Check for valid data structure
    if (response.data && response.data.result && response.data.result.length > 0) {
        const result = response.data.result[0];
        
        // Process each data point
        if (result.values && Array.isArray(result.values)) {
            result.values.forEach(point => {
                if (Array.isArray(point) && point.length === 2) {
                    const [timestamp, value] = point;
                    
                    // Format timestamp
                    const date = new Date(timestamp * 1000);
                    const timeStr = date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    
                    // Add to arrays
                    labels.push(timeStr);
                    
                    // Handle null/NaN values
                    if (value === null || value === 'NaN' || value === 'nan') {
                        values.push(null);
                    } else {
                        values.push(parseFloat(value));
                    }
                }
            });
        }
    }
    
    return { labels, values };
}

// Render chart to container
function renderChart(container, metric, chartData) {
    // Clear container
    container.innerHTML = '';
    
    // Create canvas
    const canvas = document.createElement('canvas');
    canvas.id = 'main-chart';
    canvas.className = 'trends-chart';
    container.appendChild(canvas);
    
    // Get chart configuration based on metric
    const chartConfig = getChartConfig(metric, chartData);
    
    // Create chart
    try {
        new Chart(canvas.getContext('2d'), chartConfig);
    } catch (error) {
        console.error('Error creating chart:', error);
        container.innerHTML = `<div class="error-message">Failed to create chart: ${error.message}</div>`;
    }
}

// Get chart configuration based on metric
function getChartConfig(metric, chartData) {
    let color, bgColor, label;
    
    // Determine colors and label based on metric
    switch (metric) {
        case 'temperature':
            color = '#4e73df';
            bgColor = 'rgba(78, 115, 223, 0.1)';
            label = 'Temperature (°C)';
            break;
        case 'pH':
            color = '#e74a3b';
            bgColor = 'rgba(231, 74, 59, 0.1)';
            label = 'pH';
            break;
        case 'TDS':
            color = '#1cc88a';
            bgColor = 'rgba(28, 200, 138, 0.1)';
            label = 'TDS (ppm)';
            break;
        case 'EC':
            color = '#36b9cc';
            bgColor = 'rgba(54, 185, 204, 0.1)';
            label = 'EC (μS/cm)';
            break;
        case 'distance':
            color = '#f6c23e';
            bgColor = 'rgba(246, 194, 62, 0.1)';
            label = 'Distance (m)';
            break;
        case 'ORP':
            color = '#6f42c1';
            bgColor = 'rgba(111, 66, 193, 0.1)';
            label = 'ORP (mV)';
            break;
        default:
            color = '#858796';
            bgColor = 'rgba(133, 135, 150, 0.1)';
            label = metric;
    }
    
    // Chart.js configuration
    return {
        type: 'line',
        data: {
            labels: chartData.labels.length ? chartData.labels : ['No data'],
            datasets: [{
                label: label,
                data: chartData.values.length ? chartData.values : [null],
                borderColor: color,
                backgroundColor: bgColor,
                tension: 0.4,
                borderWidth: 2,
                fill: true,
                spanGaps: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'top',
                },
                title: {
                    display: true,
                    text: chartData.labels.length ? `${label} Over Time` : 'No data available'
                }
            },
            scales: {
                y: {
                    beginAtZero: metric === 'pH' || metric === 'distance',
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)'
                    }
                },
                x: {
                    grid: {
                        display: false
                    }
                }
            }
        }
    };
}

// Load combined chart (temperature, pH, EC)
function loadCombinedChart(deviceId, timeMinutes, container) {
    fetch(`/api/trends?metrics=temperature,pH,EC&device=${deviceId}&minutes=${timeMinutes}`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (!data.status || data.status !== 'success' || !data.data) {
                throw new Error('Invalid API response format');
            }
            
            renderCombinedChart(container, deviceId, data.data);
        })
        .catch(error => {
            console.error('Error loading combined chart:', error);
            container.innerHTML = `<div class="error-message">Error loading combined chart: ${error.message}</div>`;
        });
}

// Render combined chart
function renderCombinedChart(container, deviceId, data) {
    // Clear container
    container.innerHTML = '';
    
    // Create canvas
    const canvas = document.createElement('canvas');
    canvas.id = 'main-chart';
    canvas.className = 'trends-chart';
    container.appendChild(canvas);
    
    // Process data
    const allTimestamps = new Set();
    
    // Collect all timestamps
    ['temperature', 'pH', 'EC'].forEach(metric => {
        if (Array.isArray(data[metric])) {
            data[metric].forEach(point => {
                if (Array.isArray(point) && point.length === 2) {
                    allTimestamps.add(point[0]);
                }
            });
        }
    });
    
    // Sort timestamps
    const sortedTimestamps = Array.from(allTimestamps).sort((a, b) => a - b);
    
    // Create lookup maps for each metric
    const tempMap = new Map();
    const phMap = new Map();
    const ecMap = new Map();
    
    // Populate lookup maps
    ['temperature', 'pH', 'EC'].forEach(metric => {
        if (Array.isArray(data[metric])) {
            data[metric].forEach(point => {
                if (Array.isArray(point) && point.length === 2) {
                    const [timestamp, value] = point;
                    if (metric === 'temperature') tempMap.set(timestamp, value);
                    else if (metric === 'pH') phMap.set(timestamp, value);
                    else if (metric === 'EC') ecMap.set(timestamp, value);
                }
            });
        }
    });
    
    // Format timestamps for display
    const labels = sortedTimestamps.map(ts => {
        const date = new Date(ts * 1000);
        return date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    });
    
    // Get values for each metric
    const tempValues = sortedTimestamps.map(ts => {
        const value = tempMap.get(ts);
        return value === 'NaN' || value === 'nan' ? null : value;
    });
    
    const phValues = sortedTimestamps.map(ts => {
        const value = phMap.get(ts);
        return value === 'NaN' || value === 'nan' ? null : value;
    });
    
    const ecValues = sortedTimestamps.map(ts => {
        const value = ecMap.get(ts);
        return value === 'NaN' || value === 'nan' ? null : value;
    });
    
    // Create chart
    try {
        new Chart(canvas.getContext('2d'), {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Temperature (°C)',
                        data: tempValues,
                        borderColor: '#4e73df',
                        backgroundColor: 'rgba(78, 115, 223, 0.1)',
                        tension: 0.4,
                        borderWidth: 2,
                        fill: false,
                        yAxisID: 'y-temperature',
                        spanGaps: true
                    },
                    {
                        label: 'pH',
                        data: phValues,
                        borderColor: '#e74a3b',
                        backgroundColor: 'rgba(231, 74, 59, 0.1)',
                        tension: 0.4,
                        borderWidth: 2,
                        fill: false,
                        yAxisID: 'y-ph',
                        spanGaps: true
                    },
                    {
                        label: 'EC (μS/cm)',
                        data: ecValues,
                        borderColor: '#36b9cc',
                        backgroundColor: 'rgba(54, 185, 204, 0.1)',
                        tension: 0.4,
                        borderWidth: 2,
                        fill: false,
                        yAxisID: 'y-ec',
                        spanGaps: true
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                    },
                    title: {
                        display: true,
                        text: `Device: ${deviceId}`
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false
                    }
                },
                scales: {
                    'y-temperature': {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        title: {
                            display: true,
                            text: 'Temperature (°C)'
                        },
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        }
                    },
                    'y-ph': {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        title: {
                            display: true,
                            text: 'pH'
                        },
                        grid: {
                            drawOnChartArea: false
                        },
                        min: 0,
                        max: 14
                    },
                    'y-ec': {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        title: {
                            display: true,
                            text: 'EC (μS/cm)'
                        },
                        grid: {
                            drawOnChartArea: false
                        }
                    },
                    x: {
                        grid: {
                            display: false
                        }
                    }
                }
            }
        });
    } catch (error) {
        console.error('Error creating combined chart:', error);
        container.innerHTML = `<div class="error-message">Failed to create combined chart: ${error.message}</div>`;
    }
}